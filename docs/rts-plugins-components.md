# 📚 RevTechStudioプラグイン構成要素の解説

## 📖 概要

本ドキュメントは、当チームが採用しているClaude Codeプラグインの要素定義について説明します。これらの定義は一般的な定義ではなく、当チーム独自の考え方に基づいています。

## 🔧 要素の種類

### 🤖 エージェント（Agent）

エージェントは**責任範囲が定義されている**要素です。

「誰が何に対して責任を持つか」を明確にするための要素であり、具体的な作業内容やワークフローは定義されていません。フェーズ全体を統括する役割を担います。

#### 例：Requirements Agent

- 要件定義フェーズ全体に対する責任を持つ
- ユーザーとの対話を通じて要件を整理・構造化する責任範囲を持つ

### ⚙️ スキル（Skill）

スキルは**単一作業のワークフローが記述されている**要素です。

一つの明確な目的を持った作業の手順が定義されており、その作業に必要な規約やガイドラインも含まれています。1スキル1目的の原則に従います。

#### スキルの2つの分類

当チームでは、スキルを以下の2種類に分けています。

**1. Workflow Skill（ワークフロースキル）:**

実際にワークフローに沿って具体的な作業を実行するスキルです。アウトプットを生成することが主な目的となります。

- **例：Code Generator** - 設計仕様からソースコードを生成する
- **例：API Designer** - API仕様を設計する
- **例：Database Schema Designer** - データベーススキーマを設計する

**2. Convention Skill（コンベンションスキル）:**

規約やガイドラインが定義されているスキルです。ワークフロースキル内に規約を記述すると内容が肥大化してしまう場合に、規約部分を別スキルとして分割します。

- **例：コーディング規約スキル** - 変数命名規則、インデントルールなど
- **例：API設計ガイドライン** - RESTful設計原則、エンドポイント命名規則など

基本はワークフロースキルの中に規約やガイドラインを直接記述します。ただし、スキルの肥大化を避ける目的でコンベンションスキルとして分離します。

### 💻 コマンド（Command）

コマンドは**エージェントと複数のスキルを組み合わせて作業を行うためのワークフロー**が定義されている要素です。

ユーザーが実際に実行する指示であり、一つのコマンドが複数のスキルを適切な順序で呼び出してフェーズ全体の作業を進めます。

#### コマンドの役割と依存関係の管理

**重要な設計原則**：**すべてのエージェントおよびすべてのスキルは互いに依存しません。各要素は独立した要素として確立されます。**

コマンドが以下の責任を持ちます：

- どのエージェントがどのスキルを使用するかを定義
- 成果物のファイルパスやディレクトリ構造を定義
- スキル間のデータの受け渡しを定義
- 実行順序とワークフローを定義

つまり、**依存関係についてはすべてコマンドが引き受けます**。これにより、エージェントとスキルは再利用可能な独立したコンポーネントとして設計できます。

#### エージェントとスキルにおける他要素の参照禁止

**エージェントとスキルのドキュメント内で、他のエージェント、スキル、コマンドを参照してはいけません。**

これは完全な独立性を保つための重要なルールです。

**禁止される記述例:**

- ❌ 「コーディングルールは coding-convention スキルに従う」
- ❌ 「詳細は documentation-standards スキルを参照」
- ❌ 「Requirements Agent と連携して動作する」
- ❌ 「design コマンドを実行してから使用する」
- ❌ 「interaction-guidelines スキルで定義された対話パターンを使用する」

**推奨される記述例:**

- ✅ 「コーディングルールに従う」（具体的なルールは当該スキル内に記述）
- ✅ 「ドキュメント記述標準に従う」（具体的な標準は当該スキル内に記述）
- ✅ 「要件定義フェーズに対する責任を持つ」（他のエージェントに言及しない）
- ✅ 「設計完了後に実行する」（コマンド名を明示しない）
- ✅ 「ユーザーとの対話パターンに従う」（具体的なパターンは当該スキル内に記述）

**理由:**

他の要素を参照すると、その要素への依存が生まれ、以下の問題が発生します:

- 参照先の要素が存在しない環境では使用できない
- 参照先の要素が変更されると、参照元も影響を受ける
- 要素単体での再利用が困難になる
- 他のプロジェクトへの移植性が低下する

必要な規約やガイドラインは、各エージェント・スキルのドキュメント内に直接記述するか、汎用的な表現で記載します。

#### コマンドの例

**例：`requirements` コマンド**

- Requirements Agent の責任範囲で動作
- Interaction Guideline Skill、Requirements Structurer、Domain Modelerなど複数のスキルを組み合わせる
- 各スキルの実行順序を定義
- 要件定義書の出力先を指定
- 要件定義フェーズの開始から完了までを管理

**例：`design` と `task` コマンド**

- `design`：詳細設計フェーズ全体を管理し、設計書の出力先を指定
- `task`：設計完了後にタスク分割を実行し、タスクリストの出力先を指定

各フェーズでは1〜2個のコマンドに抑えることで、ユーザーが覚えるべきコマンド数を最小限にしています。

## 📝 命名と記述のガイドライン

### 固有名詞の使用禁止

**すべてのエージェント、スキル、コマンドにおいて、固有名詞を含めないこと。**

これらの要素は汎用的に使用できるように設計されるべきであり、特定のプロジェクト、組織、製品、サービスに依存する名称や記述を避ける必要があります。このルールは、プラグインディレクトリのドキュメントに限定されます。docsディレクトリ内のドキュメントには適用されません。

#### 固有名詞を避けるべき理由

- **再利用性**: 他のプロジェクトやチームでも使用できる汎用的な要素にする
- **独立性**: 特定の環境やコンテキストに依存しない独立した要素として設計する
- **保守性**: 組織名やプロジェクト名が変更されても、要素の更新が不要になる
- **移植性**: 異なる環境や組織に簡単に移植できる

#### 避けるべき固有名詞の例

- 組織名、チーム名、企業名
- プロジェクト名、製品名、サービス名
- 特定の技術スタックやツールの名前（汎用的な場合を除く）

#### 良い例と悪い例

**エージェントの記述例:**

良い例:

```markdown
このエージェントは、すべての要件定義フェーズに対する責任を持つ。
```

悪い例:

```markdown
このエージェントは、RevTechStudioプロジェクトの要件定義フェーズに対する責任を持つ。
```

**スキルの記述例:**

良い例:

```markdown
このSkillは、開発されるすべての.NETプロジェクトに適用されるコーディング規約を定義する。
```

悪い例:

```markdown
このSkillは、RevTechStudioで開発されるすべての.NETプロジェクトに適用されるコーディング規約を定義する。
```

**コマンドの記述例:**

良い例:

```markdown
このコマンドは、要件定義フェーズ全体を管理し、要件定義書を生成する。
```

悪い例:

```markdown
このコマンドは、XYZ社の要件定義フェーズ全体を管理し、要件定義書を生成する。
```

#### コード例やサンプルにおける固有名詞

コード例やサンプルにおいても、固有名詞の使用を避けます。代わりに、以下のような汎用的なプレースホルダーを使用します:

- `YourProject`: プロジェクト名のプレースホルダー
- `YourCompany`: 組織名のプレースホルダー
- `example.com`: ドメイン名のプレースホルダー

良い例:

```csharp
namespace YourProject.Orders;

public class OrderProcessor
{
    // 実装
}
```

悪い例:

```csharp
namespace RevTechStudio.Orders;

public class OrderProcessor
{
    // 実装
}
```
