---
name: plugin-architecture-convention
description: プラグイン全体の構造設計原則（要素の役割分担、階層構造、依存関係管理）
---

# Plugin Architecture Convention

## 概要

このSkillは、プラグイン全体のアーキテクチャ設計原則を定義する。プラグインを構成する要素（エージェント、スキル、コマンド）の役割分担、依存関係管理、独立性の確保、汎用性の維持について明確な指針を提供し、再利用可能で保守性の高いプラグイン設計を実現することを目的とする。

## 責任範囲

このSkillは以下の範囲をカバーする:

- プラグイン要素（エージェント、スキル、コマンド）の定義と役割
- 要素間の依存関係管理の原則
- 独立性の原則（他要素への参照禁止ルール）
- 汎用性の原則（固有名詞の使用禁止ルール）
- スキルの分類（Workflow Skill / Convention Skill）
- コマンドの責任範囲と役割
- プラグイン要素の命名と記述のガイドライン

## 基本方針

- すべてのエージェントおよびすべてのスキルは互いに依存しない
- 各要素は独立した要素として確立される
- 依存関係についてはすべてコマンドが引き受ける
- 固有名詞を含めず、汎用的な表現を使用する
- 1スキル1目的の原則を厳守する
- 再利用可能で保守性の高い設計を重視する

## プラグイン要素の定義

### エージェント（Agent）

エージェントは**責任範囲が定義されている**要素である。

**特徴:**

- 「誰が何に対して責任を持つか」を明確にする
- 具体的な作業内容やワークフローは定義されていない
- フェーズ全体を統括する役割を担う

**例:**

- Requirements Agent: 要件定義フェーズ全体に対する責任を持つ
- Design Agent: 詳細設計フェーズ全体に対する責任を持つ

### スキル（Skill）

スキルは**単一作業のワークフローが記述されている**要素である。

**特徴:**

- 一つの明確な目的を持った作業の手順が定義されている
- その作業に必要な規約やガイドラインも含まれている
- 1スキル1目的の原則に従う

**例:**

- Code Generator: 設計仕様からソースコードを生成する
- API Designer: API仕様を設計する
- Coding Convention: コーディング規約を定義する

### コマンド（Command）

コマンドは**エージェントと複数のスキルを組み合わせて作業を行うためのワークフロー**が定義されている要素である。

**特徴:**

- ユーザーが実際に実行する指示である
- 一つのコマンドが複数のスキルを適切な順序で呼び出す
- フェーズ全体の作業を進める

**例:**

- requirements: 要件定義フェーズの開始から完了までを管理
- design: 詳細設計フェーズの開始から完了までを管理

## スキルの分類

スキルは以下の2種類に分類される。

### Workflow Skill（ワークフロースキル）

実際にワークフローに沿って具体的な作業を実行するスキルである。

**特徴:**

- アウトプットを生成することが主な目的
- 作業の手順が明確に定義されている
- 具体的な成果物を作成する

**例:**

- Code Generator: 設計仕様からソースコードを生成する
- API Designer: API仕様を設計する
- Database Schema Designer: データベーススキーマを設計する

### Convention Skill（コンベンションスキル）

規約やガイドラインが定義されているスキルである。

**特徴:**

- ワークフロースキル内に規約を記述すると内容が肥大化する場合に分割
- 基本はワークフロースキルの中に規約を直接記述する
- スキルの肥大化を避ける目的で分離する

**例:**

- Coding Convention: 変数命名規則、インデントルールなど
- API Design Guideline: RESTful設計原則、エンドポイント命名規則など
- Documentation Standard: ドキュメント記述標準、構造の標準化など

## 依存関係管理の原則

### コマンドが依存関係を管理する

すべてのエージェントおよびすべてのスキルは互いに依存しない。コマンドが以下の責任を持つ:

- どのエージェントがどのスキルを使用するかを定義
- 成果物のファイルパスやディレクトリ構造を定義
- スキル間のデータの受け渡しを定義
- 実行順序とワークフローを定義

### エージェントとスキルの独立性

エージェントとスキルは再利用可能な独立したコンポーネントとして設計される。

**原則:**

- エージェントは他のエージェントに依存しない
- スキルは他のスキルに依存しない
- エージェントは特定のスキルに依存しない
- スキルは特定のエージェントに依存しない

## 独立性の原則（他要素への参照禁止）

### 参照禁止ルール

エージェントとスキルのドキュメント内で、他のエージェント、スキル、コマンドを参照してはいけない。

**理由:**

- 参照先の要素が存在しない環境では使用できない
- 参照先の要素が変更されると、参照元も影響を受ける
- 要素単体での再利用が困難になる
- 他のプロジェクトへの移植性が低下する

### 必要な情報の記述方法

必要な規約やガイドラインは、各エージェント・スキルのドキュメント内に直接記述するか、汎用的な表現で記載する。

良い例:

```markdown
コーディングルールに従う
（具体的なルールは当該スキル内に記述）

ドキュメント記述標準に従う
（具体的な標準は当該スキル内に記述）

要件定義フェーズに対する責任を持つ
（他のエージェントに言及しない）

設計完了後に実行する
（コマンド名を明示しない）

ユーザーとの対話パターンに従う
（具体的なパターンは当該スキル内に記述）
```

悪い例:

```markdown
コーディングルールは coding-convention スキルに従う
（他のスキルを参照している）

詳細は documentation-standards スキルを参照
（他のスキルを参照している）

Requirements Agent と連携して動作する
（他のエージェントを参照している）

design コマンドを実行してから使用する
（他のコマンドを参照している）

interaction-guidelines スキルで定義された対話パターンを使用する
（他のスキルを参照している）
```

## 汎用性の原則（固有名詞禁止）

### 固有名詞の使用禁止

すべてのエージェント、スキル、コマンドにおいて、固有名詞を含めない。

**対象:**

- 組織名、チーム名、企業名
- プロジェクト名、製品名、サービス名
- 特定の技術スタックやツールの名前（汎用的な場合を除く）

**理由:**

- 再利用性: 他のプロジェクトやチームでも使用できる汎用的な要素にする
- 独立性: 特定の環境やコンテキストに依存しない独立した要素として設計する
- 保守性: 組織名やプロジェクト名が変更されても、要素の更新が不要になる
- 移植性: 異なる環境や組織に簡単に移植できる

### コード例やサンプルにおける固有名詞

コード例やサンプルにおいても、固有名詞の使用を避ける。代わりに、以下のような汎用的なプレースホルダーを使用する:

- `YourProject`: プロジェクト名のプレースホルダー
- `YourCompany`: 組織名のプレースホルダー
- `example.com`: ドメイン名のプレースホルダー

良い例（エージェントの記述）:

```markdown
このエージェントは、すべての要件定義フェーズに対する責任を持つ。
```

悪い例（エージェントの記述）:

```markdown
このエージェントは、XYZ社プロジェクトの要件定義フェーズに対する責任を持つ。
```

良い例（スキルの記述）:

```markdown
このSkillは、開発されるすべての.NETプロジェクトに適用されるコーディング規約を定義する。
```

悪い例（スキルの記述）:

```markdown
このSkillは、ABC社で開発されるすべての.NETプロジェクトに適用されるコーディング規約を定義する。
```

良い例（コマンドの記述）:

```markdown
このコマンドは、要件定義フェーズ全体を管理し、要件定義書を生成する。
```

悪い例（コマンドの記述）:

```markdown
このコマンドは、XYZ社の要件定義フェーズ全体を管理し、要件定義書を生成する。
```

良い例（コード例）:

```csharp
namespace YourProject.Orders;

public class OrderProcessor
{
    // 実装
}
```

悪い例（コード例）:

```csharp
namespace RevTechStudio.Orders;

public class OrderProcessor
{
    // 実装
}
```

## コマンドの責任範囲

### コマンドの役割

コマンドは以下の責任を持つ:

- どのエージェントがどのスキルを使用するかを定義
- 成果物のファイルパスやディレクトリ構造を定義
- スキル間のデータの受け渡しを定義
- 実行順序とワークフローを定義

### コマンドの粒度

各フェーズでは1〜2個のコマンドに抑えることで、ユーザーが覚えるべきコマンド数を最小限にする。

**例:**

- `requirements`: 要件定義フェーズ全体を管理
- `design`: 詳細設計フェーズ全体を管理し、設計書の出力先を指定
- `task`: 設計完了後にタスク分割を実行し、タスクリストの出力先を指定

## 命名と記述のガイドライン

### エージェントの命名

- エージェントの役割を表す名前を使用する
- 責任範囲が明確にわかる名前にする
- ケバブケース（例: requirements-agent, design-agent）を使用する

### スキルの命名

- スキルの目的を表す名前を使用する
- ワークフロースキルは動詞を含む名前にする（例: code-generator, api-designer）
- コンベンションスキルは規約の対象を表す名前にする（例: coding-conventions, documentation-standards）
- ケバブケース（例: code-generator, coding-conventions）を使用する

### コマンドの命名

- コマンドの機能を表す名前を使用する
- ユーザーが覚えやすい簡潔な名前にする
- ケバブケース（例: requirements, design, task）を使用する

### ドキュメント記述の原則

- 日本語で記述する
- 常体で記述する
- 簡潔で明確な文章を使用する
- 箇条書きを活用して情報を整理する

## チェックリスト

### エージェント定義時

- [ ] 責任範囲が明確に定義されている
- [ ] 他のエージェント、スキル、コマンドを参照していない
- [ ] 固有名詞を含めていない
- [ ] 具体的な作業内容やワークフローを記述していない
- [ ] フェーズ全体を統括する役割が明確である

### スキル定義時

- [ ] 1スキル1目的の原則を守っている
- [ ] 単一作業のワークフローが明確に定義されている
- [ ] 他のエージェント、スキル、コマンドを参照していない
- [ ] 固有名詞を含めていない
- [ ] 必要な規約やガイドラインをスキル内に直接記述している
- [ ] Workflow SkillまたはConvention Skillのいずれかに分類できる

### コマンド定義時

- [ ] どのエージェントがどのスキルを使用するかが定義されている
- [ ] 成果物のファイルパスやディレクトリ構造が定義されている
- [ ] スキル間のデータの受け渡しが定義されている
- [ ] 実行順序とワークフローが定義されている
- [ ] ユーザーが覚えやすい簡潔な名前である
- [ ] 固有名詞を含めていない

### 最終確認

- [ ] すべての要素が互いに依存していない
- [ ] 依存関係がコマンドで管理されている
- [ ] 他要素への参照が含まれていない
- [ ] 固有名詞が使用されていない
- [ ] 再利用可能で保守性の高い設計になっている
- [ ] ドキュメントが明確で理解しやすい
